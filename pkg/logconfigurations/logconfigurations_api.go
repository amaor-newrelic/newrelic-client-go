// Code generated by tutone: DO NOT EDIT
package logconfigurations

import (
	"context"

	"github.com/newrelic/newrelic-client-go/v2/pkg/errors"
)

// Create an obfuscation expression.
func (a *Logconfigurations) LogConfigurationsCreateObfuscationExpression(
	accountID int,
	expression LogConfigurationsCreateObfuscationExpressionInput,
) (*LogConfigurationsObfuscationExpression, error) {
	return a.LogConfigurationsCreateObfuscationExpressionWithContext(context.Background(),
		accountID,
		expression,
	)
}

// Create an obfuscation expression.
func (a *Logconfigurations) LogConfigurationsCreateObfuscationExpressionWithContext(
	ctx context.Context,
	accountID int,
	expression LogConfigurationsCreateObfuscationExpressionInput,
) (*LogConfigurationsObfuscationExpression, error) {

	resp := LogConfigurationsCreateObfuscationExpressionQueryResponse{}
	vars := map[string]interface{}{
		"accountId":  accountID,
		"expression": expression,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsCreateObfuscationExpressionMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationExpression, nil
}

type LogConfigurationsCreateObfuscationExpressionQueryResponse struct {
	LogConfigurationsObfuscationExpression LogConfigurationsObfuscationExpression `json:"LogConfigurationsCreateObfuscationExpression"`
}

const LogConfigurationsCreateObfuscationExpressionMutation = `mutation(
	$accountId: Int!,
	$expression: LogConfigurationsCreateObfuscationExpressionInput!,
) { logConfigurationsCreateObfuscationExpression(
	accountId: $accountId,
	expression: $expression,
) {
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	id
	name
	regex
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Create an obfuscation rule.
func (a *Logconfigurations) LogConfigurationsCreateObfuscationRule(
	accountID int,
	rule LogConfigurationsCreateObfuscationRuleInput,
) (*LogConfigurationsObfuscationRule, error) {
	return a.LogConfigurationsCreateObfuscationRuleWithContext(context.Background(),
		accountID,
		rule,
	)
}

// Create an obfuscation rule.
func (a *Logconfigurations) LogConfigurationsCreateObfuscationRuleWithContext(
	ctx context.Context,
	accountID int,
	rule LogConfigurationsCreateObfuscationRuleInput,
) (*LogConfigurationsObfuscationRule, error) {

	resp := LogConfigurationsCreateObfuscationRuleQueryResponse{}
	vars := map[string]interface{}{
		"accountId": accountID,
		"rule":      rule,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsCreateObfuscationRuleMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationRule, nil
}

type LogConfigurationsCreateObfuscationRuleQueryResponse struct {
	LogConfigurationsObfuscationRule LogConfigurationsObfuscationRule `json:"LogConfigurationsCreateObfuscationRule"`
}

const LogConfigurationsCreateObfuscationRuleMutation = `mutation(
	$accountId: Int!,
	$rule: LogConfigurationsCreateObfuscationRuleInput!,
) { logConfigurationsCreateObfuscationRule(
	accountId: $accountId,
	rule: $rule,
) {
	actions {
		attributes
		expression {
			createdAt
			createdBy {
				email
				gravatar
				id
				name
			}
			description
			id
			name
			regex
			updatedAt
			updatedBy {
				email
				gravatar
				id
				name
			}
		}
		id
		method
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	enabled
	filter
	id
	name
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Delete an obfuscation expression.
func (a *Logconfigurations) LogConfigurationsDeleteObfuscationExpression(
	accountID int,
	iD string,
) (*LogConfigurationsObfuscationExpression, error) {
	return a.LogConfigurationsDeleteObfuscationExpressionWithContext(context.Background(),
		accountID,
		iD,
	)
}

// Delete an obfuscation expression.
func (a *Logconfigurations) LogConfigurationsDeleteObfuscationExpressionWithContext(
	ctx context.Context,
	accountID int,
	iD string,
) (*LogConfigurationsObfuscationExpression, error) {

	resp := LogConfigurationsDeleteObfuscationExpressionQueryResponse{}
	vars := map[string]interface{}{
		"accountId": accountID,
		"id":        iD,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsDeleteObfuscationExpressionMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationExpression, nil
}

type LogConfigurationsDeleteObfuscationExpressionQueryResponse struct {
	LogConfigurationsObfuscationExpression LogConfigurationsObfuscationExpression `json:"LogConfigurationsDeleteObfuscationExpression"`
}

const LogConfigurationsDeleteObfuscationExpressionMutation = `mutation(
	$accountId: Int!,
	$id: ID!,
) { logConfigurationsDeleteObfuscationExpression(
	accountId: $accountId,
	id: $id,
) {
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	id
	name
	regex
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Delete an obfuscation rule.
func (a *Logconfigurations) LogConfigurationsDeleteObfuscationRule(
	accountID int,
	iD string,
) (*LogConfigurationsObfuscationRule, error) {
	return a.LogConfigurationsDeleteObfuscationRuleWithContext(context.Background(),
		accountID,
		iD,
	)
}

// Delete an obfuscation rule.
func (a *Logconfigurations) LogConfigurationsDeleteObfuscationRuleWithContext(
	ctx context.Context,
	accountID int,
	iD string,
) (*LogConfigurationsObfuscationRule, error) {

	resp := LogConfigurationsDeleteObfuscationRuleQueryResponse{}
	vars := map[string]interface{}{
		"accountId": accountID,
		"id":        iD,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsDeleteObfuscationRuleMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationRule, nil
}

type LogConfigurationsDeleteObfuscationRuleQueryResponse struct {
	LogConfigurationsObfuscationRule LogConfigurationsObfuscationRule `json:"LogConfigurationsDeleteObfuscationRule"`
}

const LogConfigurationsDeleteObfuscationRuleMutation = `mutation(
	$accountId: Int!,
	$id: ID!,
) { logConfigurationsDeleteObfuscationRule(
	accountId: $accountId,
	id: $id,
) {
	actions {
		attributes
		expression {
			createdAt
			createdBy {
				email
				gravatar
				id
				name
			}
			description
			id
			name
			regex
			updatedAt
			updatedBy {
				email
				gravatar
				id
				name
			}
		}
		id
		method
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	enabled
	filter
	id
	name
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Update an existing data partition rule.
func (a *Logconfigurations) LogConfigurationsUpdateObfuscationExpression(
	accountID int,
	expression LogConfigurationsUpdateObfuscationExpressionInput,
) (*LogConfigurationsObfuscationExpression, error) {
	return a.LogConfigurationsUpdateObfuscationExpressionWithContext(context.Background(),
		accountID,
		expression,
	)
}

// Update an existing data partition rule.
func (a *Logconfigurations) LogConfigurationsUpdateObfuscationExpressionWithContext(
	ctx context.Context,
	accountID int,
	expression LogConfigurationsUpdateObfuscationExpressionInput,
) (*LogConfigurationsObfuscationExpression, error) {

	resp := LogConfigurationsUpdateObfuscationExpressionQueryResponse{}
	vars := map[string]interface{}{
		"accountId":  accountID,
		"expression": expression,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsUpdateObfuscationExpressionMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationExpression, nil
}

type LogConfigurationsUpdateObfuscationExpressionQueryResponse struct {
	LogConfigurationsObfuscationExpression LogConfigurationsObfuscationExpression `json:"LogConfigurationsUpdateObfuscationExpression"`
}

const LogConfigurationsUpdateObfuscationExpressionMutation = `mutation(
	$accountId: Int!,
	$expression: LogConfigurationsUpdateObfuscationExpressionInput!,
) { logConfigurationsUpdateObfuscationExpression(
	accountId: $accountId,
	expression: $expression,
) {
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	id
	name
	regex
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Update an existing data partition rule.
func (a *Logconfigurations) LogConfigurationsUpdateObfuscationRule(
	accountID int,
	rule LogConfigurationsUpdateObfuscationRuleInput,
) (*LogConfigurationsObfuscationRule, error) {
	return a.LogConfigurationsUpdateObfuscationRuleWithContext(context.Background(),
		accountID,
		rule,
	)
}

// Update an existing data partition rule.
func (a *Logconfigurations) LogConfigurationsUpdateObfuscationRuleWithContext(
	ctx context.Context,
	accountID int,
	rule LogConfigurationsUpdateObfuscationRuleInput,
) (*LogConfigurationsObfuscationRule, error) {

	resp := LogConfigurationsUpdateObfuscationRuleQueryResponse{}
	vars := map[string]interface{}{
		"accountId": accountID,
		"rule":      rule,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, LogConfigurationsUpdateObfuscationRuleMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.LogConfigurationsObfuscationRule, nil
}

type LogConfigurationsUpdateObfuscationRuleQueryResponse struct {
	LogConfigurationsObfuscationRule LogConfigurationsObfuscationRule `json:"LogConfigurationsUpdateObfuscationRule"`
}

const LogConfigurationsUpdateObfuscationRuleMutation = `mutation(
	$accountId: Int!,
	$rule: LogConfigurationsUpdateObfuscationRuleInput!,
) { logConfigurationsUpdateObfuscationRule(
	accountId: $accountId,
	rule: $rule,
) {
	actions {
		attributes
		expression {
			createdAt
			createdBy {
				email
				gravatar
				id
				name
			}
			description
			id
			name
			regex
			updatedAt
			updatedBy {
				email
				gravatar
				id
				name
			}
		}
		id
		method
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	enabled
	filter
	id
	name
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} }`

// Look up for all obfuscation expressions for a given account
func (a *Logconfigurations) GetObfuscationExpressions(
	accountID int,
) (*[]LogConfigurationsObfuscationExpression, error) {
	return a.GetObfuscationExpressionsWithContext(context.Background(),
		accountID,
	)
}

// Look up for all obfuscation expressions for a given account
func (a *Logconfigurations) GetObfuscationExpressionsWithContext(
	ctx context.Context,
	accountID int,
) (*[]LogConfigurationsObfuscationExpression, error) {

	resp := obfuscationExpressionsResponse{}
	vars := map[string]interface{}{
		"accountID": accountID,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, getObfuscationExpressionsQuery, vars, &resp); err != nil {
		return nil, err
	}

	if len(resp.Actor.Account.LogConfigurations.ObfuscationExpressions) == 0 {
		return nil, errors.NewNotFound("")
	}

	return &resp.Actor.Account.LogConfigurations.ObfuscationExpressions, nil
}

const getObfuscationExpressionsQuery = `query(
	$accountID: Int!,
) { actor { account(id: $accountID) { logConfigurations { obfuscationExpressions {
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	id
	name
	regex
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} } } } }`

// Look up for all obfuscation rules for a given account.
func (a *Logconfigurations) GetObfuscationRules(
	accountID int,
) (*[]LogConfigurationsObfuscationRule, error) {
	return a.GetObfuscationRulesWithContext(context.Background(),
		accountID,
	)
}

// Look up for all obfuscation rules for a given account.
func (a *Logconfigurations) GetObfuscationRulesWithContext(
	ctx context.Context,
	accountID int,
) (*[]LogConfigurationsObfuscationRule, error) {

	resp := obfuscationRulesResponse{}
	vars := map[string]interface{}{
		"accountID": accountID,
	}

	if err := a.client.NerdGraphQueryWithContext(ctx, getObfuscationRulesQuery, vars, &resp); err != nil {
		return nil, err
	}

	if len(resp.Actor.Account.LogConfigurations.ObfuscationRules) == 0 {
		return nil, errors.NewNotFound("")
	}

	return &resp.Actor.Account.LogConfigurations.ObfuscationRules, nil
}

const getObfuscationRulesQuery = `query(
	$accountID: Int!,
) { actor { account(id: $accountID) { logConfigurations { obfuscationRules {
	actions {
		attributes
		expression {
			createdAt
			createdBy {
				email
				gravatar
				id
				name
			}
			description
			id
			name
			regex
			updatedAt
			updatedBy {
				email
				gravatar
				id
				name
			}
		}
		id
		method
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	description
	enabled
	filter
	id
	name
	updatedAt
	updatedBy {
		email
		gravatar
		id
		name
	}
} } } } }`
